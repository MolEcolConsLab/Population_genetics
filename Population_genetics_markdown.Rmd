---
title: "Population genetics"
author: "MEC Lab"
date: '2022-08-26'
output: html_document
---

## Load packages
```{r, warning=FALSE, echo = FALSE}
library(tidyverse)
library(dartR)
library(poppr)
library(vcfR)
library(adegenet)
library(hierfstat)
library(pophelper)
library(gridExtra)
library(ggpubr)
library(strataG)
library(mapdata)
library(viridis)
library(poppr)
library(wesanderson)
library(ape)
library(reshape2)
```



## Read in data and create genind object with populations
Note that the population map should be two columns: sample ID and linked population.
```{r, echo = FALSE}
#Read in VCF file
in_vcf <- read.vcfR("G://My Drive/MEC_lab_projects.lnk/Uro snail genomics/Data_analyses/snail_RADdata_Summer2022_fullanalyses/02_SNP_filtering/UroFull_M1n6/UroFull_M1n6_filtered.vcf", convertNA = T)

#Convert vcf to genlight
genlight.orig <- vcfR2genlight(in_vcf)

#Read in white list of individuals. This should be a text file with a single column containing the names of the individuals that were retained after filtering.
whitelist.indvs <- read.delim("G://My Drive/MEC_lab_projects.lnk/Uro snail genomics/Data_analyses/snail_RADdata_Summer2022_fullanalyses/02_SNP_filtering/UroFull_M1n6/Whitelist_indivs.txt", header = F) %>% pull()

#Read in the population map. This should be a two-column tab-delimited text file where the first column contains the name of each individual sample and the second column contains the population. This can be the same as the population map used in Stacks.
popmap.orig <- read_tsv("G://My Drive/MEC_lab_projects.lnk/Uro snail genomics/Data_analyses/snail_RADdata_Summer2022_fullanalyses/02_SNP_filtering/UroFull_M1n6/popmap_full.txt", col_names = F) %>% 
  dplyr::rename(Indiv = X1, STRATA = X2)


#-------------------Subset the full set of samples for analysis------------------------
#Only run this section if you want to run the analysis on a subset of individuals included in the filtered VCF file. If you want to run on all the samples in the vcf file that was loaded, then skip this section

#Create a blacklist of individuals that we don't want to include in the analysis so we can drop them from the genlight object
blacklist.indvs <- popmap.orig %>% dplyr::filter(!Indiv %in% whitelist.indvs) %>% 
  pull(Indiv)

#To drop blacklisted individuals. Note that this will not run if the blacklist solely includes individuals that were already filtered.
genlight <- gl.drop.ind(genlight.orig, ind.list = blacklist.indvs, mono.rm = TRUE)


#-------------------Finish creating genlight and genind objects--------------------------
# Filter the population map for whitelisted individuals i.e. those we will keep for the population genetics analysis.
popmap.filtered <- tibble(Indiv = genlight@ind.names) %>% left_join(popmap.orig, by = "Indiv")

genlight@pop <- as.factor(popmap.filtered$STRATA)
genind <- gl2gi(genlight) # need genind format for some functions
genind@pop <- factor(popmap.filtered$STRATA)
summary(genlight@pop)
summary(genind@pop)
```


## PCA 
Proportion of variation explained by PCA axes
```{r, echo = FALSE}
pca1 <- glPca(genlight,center = T, scale = T, nf = 5)
barplot(100*pca1$eig/sum(pca1$eig), col = heat.colors(50), main="PCA Eigenvalues") # retain first 5 axes, incremental decrease after 2
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="Eigenvalues", line = 1)

#proportion of explained variance by first three axes
a1<-pca1$eig[1]/sum(pca1$eig) # proportion of variation explained by 1st axis
a2<-pca1$eig[2]/sum(pca1$eig) # proportion of variation explained by 2nd axis 
a3<-pca1$eig[3]/sum(pca1$eig) # proportion of variation explained by 3rd axis
pcvar <- data.frame(Axis = c(1:3), Proportion = c(a1,a2,a3))
pcvar
```

<<<<<<< HEAD
=======


>>>>>>> 42d684c33e35ae838a61ecf2b5856bec74efb5e7
### Extract PC scores to color by location/yr:
(adapted from [Grunwald lab github](https://github.com/grunwaldlab/Population_Genetics_in_R/blob/master/gbs_analysis.Rmd#principal-components-analysis))
```{r, fig.width = 6,fig.height = 6, echo = FALSE}
pca1.scores <- as.data.frame(pca1$scores)
pca1.scores$pop <- pop(genlight)
pca1.scores$reg <- pca1.scores$pop
```

<<<<<<< HEAD
=======


>>>>>>> 42d684c33e35ae838a61ecf2b5856bec74efb5e7
### Generate PCA plots
```{r}
set.seed(9)
num_pops <- length(levels(factor(popmap.filt)))
pop_cols <- get_palette(k = num_pops, palette = "Set1")

# plot PC 1 and 2
p12 <- ggplot(pca1.scores, aes(x=PC1, y=PC2, colour=pop))
p12 <- p12 + geom_point(size=2,shape=17)
p12 <- p12 + stat_ellipse(level = 0.95, size = 1)
p12 <- p12 + scale_color_manual(values = pop_cols, name = "Locality and Year", labels = levels(genlight@pop))
p12 <- p12 + geom_hline(yintercept = 0) 
p12 <- p12 + geom_vline(xintercept = 0) 
p12 <- p12 + theme_classic()
p12
# #plot  PC 2 and 3: not informative for this dataset
# p13 <- ggplot(pca1.scores, aes(x=PC1, y=PC3, colour=pop))
# p13 <- p13 + geom_point(size=2,shape=17)
# p13 <- p13 + stat_ellipse(level = 0.95, size = 1)
# p13 <- p13 + scale_color_manual(values = pop_cols, name = "Locality and Year", labels = levels(Alewife.genlight@pop))
# p13 <- p13 + geom_hline(yintercept = 0) 
# p13 <- p13 + geom_vline(xintercept = 0) 
# p13 <- p13 + theme_bw()
# p13

# ggsave("p12.pdf", width = 7, height=7)
```

<<<<<<< HEAD
## DAPC
### Find elbow in plot of BIC vs. K
```{r}
#Change plot window to make it easier to visualize trends as # of PCs increases.
par(mfrow = c(2,2))
#find clusters
# k <- find.clusters(Alewife.genlight, scale = FALSE)
#Loop over different numbers of PCs and plot k vs BIC
#Values originally 15-100, changed to 1-50
for(i in seq(1, 50, by = 5)){
  var <- paste0("k.",i,".PCs") #Make name to save output
  k <- find.clusters(genlight, scale = FALSE, n.pca = i, choose.n.clust = FALSE, criterion = "diffNgroup") #run main function
  plot(k$Kstat, type = "b", col = "blue", main = paste0("PCs = ", i), ylab = "BIC", xlab = "k value") #Plot results
  assign(var, k) #Save output
}
```

### Run DAPC analysis to find optimal number of PCs
If scale is set to TRUE, then uninformative alleles may be given more weight
Set number of PCs to highest number of PCs that returns a reasonable k vs BIC plot. Select a k value that you think reasonably represents the data
=======

## Genetic Diversity and FST
## Genetic distance between locality and year combos. This is FST but can easily change
```{r, echo = FALSE}
pop.fst <- genet.dist(genind, method = "WC84")
pop.fst.df <- as.data.frame(as.matrix(round(pop.fst, 3)))
pop.fst.df
# write.csv(pop.fst.df,"RH_M3_fst.csv")
```


*Run the DPCA without any prior information*
The chunk here is to determine the optimal value of K (clusters) to use for downstream analyses using k-means clustering. As per the documenttaion from `find.clusters`:

"The rule of thumb consists in increasing K until it no longer leads to an appreciable improvement of fit (i.e., to a decrease of BIC). In the most simple models (island models), BIC decreases until it reaches the optimal K, and then increases. In these cases, our rule amounts to choosing the lowest K. In other models such as stepping stones, the decrease of BIC often continues after the optimal K, but is much less steep."
```{r, echo=TRUE}
n_individuals <- length(popmap.filt)
n_pops <- length(levels(factor(popmap.filt)))

grp_all <- find.clusters(genind, max.n.clust=n_pops, n.pca=200,
                         choose.n.clust = FALSE)
BIC<-as.data.frame(cbind(seq(1,n_pops,1), grp_all$Kstat))
ggline(BIC, x = "V1", y = "V2", plot_type = "b",
       col = "navy",
       xlab = "Number of clusters (K)",
       ylab = "BIC Value",
       title = "Selection of optimum number of clusters (K)") + font("xlab", face = "bold") + font("ylab", face = "bold")
grp_all$Kstat

```


Based on the output of the plot above, we select the optimal value of K. In this case, K=6, and observe the number of samples per cluster:
```{r, echo=TRUE}
grp_all <- find.clusters(genind, max.n.clust=n_pops, n.pca=200, n.clust = 6)
grp_all$size
```

Run the DPCA and generate the plots for visualizing
Selecting the right number of DAs is important as it impacts the downstream outputs, and too many PCAs can lead to over-fitting the data.
>>>>>>> 42d684c33e35ae838a61ecf2b5856bec74efb5e7
```{r}
dapc <- dapc(genind, grp_all$grp, n.pca=60, n.da = 5, var.contrib = TRUE)
pal <- get_palette("Accent", k=6)
dpca_result <- scatter(dapc, col=pal, scree.pca = TRUE,
                       pch = 20, cell = 0, cstar = 1,
                       solid = 0.8, cex = 3, clab = 1)
set.seed(4)
#contrib<-loadingplot(dapc$var.contr,axis=2, thres=.002,lab.jitter=1)
compoplot(dapc, posi="topleft", txt.leg=paste("Cluster",1:6),
          ncol=1, xlab="Individuals", col=pal, lab=genind@pop, show.lab = T)
dapc$IND <- row.names(dapc$ind.coord)
dapc_info <- as.data.frame(cbind(dapc$IND, dapc$ind.coord, grp_all$grp))
colnames(dapc_info) <- c("IND","DPC1", "DPC2", "DPC3", "DPC4", "DPC5", "K")
dapc_info$SITE <- substr(dapc_info$IND, 1,2)
dapc_info
```

<<<<<<< HEAD
## Genetic Diversity and FST
Calculate pop-level diversity, pooling the two time periods
=======
*Now use the first DPCA to inform a secondary DPCA using priors*
```{r, echo=TRUE}
set.seed(5); dapc_a_score <- dapc(genind,n.pca=100,n.da=10) 
temp_score <- optim.a.score(dapc_a_score)
dapc2 <-dapc(genind,genind@pop, n.pca=12, n.da=5)
dapc2$IND <- row.names(dapc2$ind.coord)
dapc2_info <- as.data.frame(cbind(dapc2$IND, dapc2$ind.coord, grp_all$grp))

dpca_result <- scatter(dapc2, col=pal, scree.pca = TRUE,
                       pch = 20, cell = 0, cstar = 1,
                       solid = 0.8, cex = 3, clab = 1)
load_dpca2 <- as.data.frame(dapc2$var.contr)
write.table(load_dpca2, "PopGen/Loadings_SNPs.txt", sep="\t", row.names=FALSE, quote=FALSE)
percent= dapc2$eig/sum(dapc2$eig)*100
barplot(percent, ylab="Percent of genetic variance explained by eigenvectors", names.arg=round(percent,2))
dapc_prior=as.data.frame(dapc2$ind.coord)
write.table(dapc_prior, "PopGen/DCPA_prior_results.txt", quote=F, sep="\t", row.names=TRUE)

### Add information to the tab results of the DPCA
dapc_prior$IND <- row.names(dapc_prior)

### Add site info
dapc_prior$SITE <- substr(dapc_prior$IND, 1,2)

### Add 'region' info:
dapc_prior<-merge(dapc_prior, region, by.x = "SITE", by.y = "Population")

### Make a ggplot graph representing the DAPC for the first and second axes for the regions
uro_pal<-get_palette(palette = "Paired", k = 15)
region_pal<-wes_palette("Royal1",n = 3)
ggscatter(dapc_prior, x = "LD1", y = "LD2", shape = 21, fill = "SITE", size = 3,
          xlab = "DA1 (30.9%)", ylab = "DA2 (29.9%)", palette = uro_pal)
#ggscatter(dapc_prior, x = "LD1", y = "LD2", shape = 21, fill = "Region", size = 4,
#          xlab = "DA1 (30.9%)", ylab = "DA2 (29.9%)", palette = region_pal)

### Save the ggplot graph
ggsave("PopGen/DPCA_prior_UroM1n6_scen1.pdf",width=12,height=10,dpi=600,units="cm",useDingbats=F)

```






## Genetic structure
Transfer vcf to the cluster and run fastStructure.sh, then copy output directory to working directory. Alternatively, run fastStructure commands from Terminal on own computer. Follow hackmd: https://hackmd.io/rr_rXY6aSGmRBSqnYV6iBA?view
The first portion can be skipped if using structure_threader and plot.ly to generate barplots.
```{r, fig.width = 6,fig.height = 6}
# sfiles <- list.files(path = "./RH_M3_fastStructure/RH_M3", pattern = "*meanQ",full.names = T)
# slist <- readQ(files=sfiles)
# 
# labels <- popmap.filtered
# labels$sort <- recode(labels$V2, EastGrand_2004="a", EastGrand_2018="b", 
#                            GrandFalls_2004="c", GrandFalls_2019="d", Woodland_2019="e",
#                            Milltown_2004="f", Milltown_2018="g",
#                            Dennis_2004="h")
#fastStructure barplots don't display easily in markdown so the following code writes to a file called "qplot.png". Colors are not meaningful from one K to the next.
# #this is kind of clunky
# pq <- plotQ(slist[c(1,3:9,2),1)],imgoutput="join",returnplot=F,exportplot=T,exportpath="./RH_M3_fastStructure/",outputfilename = "qplot",imgtype="png",basesize=11, grplab=labels[,2:3], selgrp = "sort", ordergrp = T, grplabsize=4, grplabangle = 20,grplabheight = 15,width = 30, linesize=0.8,pointsize=4,panelratio = c(1,1.5))
# 
# s2 <- readQ("./RH_M3_fastStructure/RH_M3/fS_run_K.2.meanQ", indlabfromfile = FALSE)
# rownames(s2[[1]]) <- labels$V1
# pindv <- plotQ(s2,imgoutput="sep",returnplot=F,exportplot=T,exportpath="./RH_M3_fastStructure/RH_M3/",outputfilename = "K2",imgtype="png",basesize=11, selgrp = "sort", grplab=labels, ordergrp = T, grplabsize=2, grplabangle = 90,grplabheight = 15,width = 30, linesize=0.8,pointsize=4,panelratio = c(1,1.5))
# Plot Marginal Likelihood vs. K
lfiles <- list.files(path = "./RH_M3_fastStructure/RH_M3", pattern = "*log",full.names = T)
lfiles
k.df <- data.frame(matrix(ncol = 2, nrow = 10))
names(k.df) <- c("K","Marginal_Likelihood")
# Filenames are out of order, 10 comes before 2, so need to fix that
k.df$K <- c(1,10,2,3,4,5,6,7,8,9)
for (i in 1:length(lfiles)){
  k.df$Marginal_Likelihood[i] <- 
    as.numeric(str_sub(grep("Marginal Likelihood = ", 
                            readLines(lfiles[[i]],),value = TRUE),-13))
}
k.df <- k.df[order(k.df$K),]
# fastStructure provides 2 metrics for determining the "best" K
readLines("./RH_M3_fastStructure/RH_M3/bestK/chooseK.txt")
q <- ggplot(k.df, mapping = aes(x=K, y=Marginal_Likelihood))
q <- q + ylim(-1,-0.5)
q <- q + geom_point(size=3, shape = 16)
q <- q + labs(x="K", y="Marginal Likelihood")
q <- q + theme_classic()
q
# ggsave("./SNP_Filtering/RH_M3_fastStructure/RH_M3/Kplot.png", width = 4.5, height=4)
```


## Calculate heterozygosity and FIS
**This section needs some work. Giving NAs for some populations for Hobs. Also takes a long time to run. Gotta be a better way to do this ... think I can just use a tidy dataframe and a custom function.**
>>>>>>> 42d684c33e35ae838a61ecf2b5856bec74efb5e7
```{r, echo=FALSE}
tidy.vcf <- vcfR2tidy(in_vcf)
tidy.gt <- tidy.vcf$gt %>% left_join(popmap, by = "Indiv")

# options(scipen = 999)
Sum <- summary(genind)

#These two functions are slow
Hobs <- t(sapply(seppop(genind), function(ls) summary(ls)$Hobs))
Hexp <- t(sapply(seppop(genind), function(ls) summary(ls)$Hexp))

Sum$n.by.pop
Hobs.pop <- apply(Hobs, MARGIN = 1, FUN = mean)
Hexp.pop <- apply(Hexp, 1, mean) 
bypop <- seppop(genind)

#This takes a bit to run
bypop.basic <- lapply(X=bypop, FUN=basic.stats) 

basicstatbypop <- data.frame(matrix(ncol = 10, nrow = 8))
names(basicstatbypop) <- names(bypop.basic[[1]]$overall)
for (i in 1:length(bypop)){
  basicstatbypop[i,] <- bypop.basic[[i]]$overall
}

gendivstats <- as.data.frame(cbind(levels(genlight@pop),Sum$n.by.pop,round(Hobs.pop, 4),round(Hexp.pop, 4), basicstatbypop$Fis))
names(gendivstats) <- c("Pop","N", "Hobs", "Hexp", "FIS")

gendivstats$FIS <- as.numeric(gendivstats$FIS)
# as_tibble(basicstatbypop)
as_tibble(gendivstats)
``` 


### Get 95% bootstrap CI for FIS
```{r}
Fis <- lapply(X=bypop,FUN=boot.ppfis)
Fis.df <- data.frame(matrix(ncol = 2, nrow = num_pops))
names(Fis.df) <- c("ll","hl")
for (i in 1:length(Fis)) {
  Fis.df$ll[i] <- Fis[[i]][2]$fis.ci[1,1]
  Fis.df$hl[i] <- Fis[[i]][2]$fis.ci[1,2]
  }
Fis.df <- cbind(gendivstats[,c(1,5)],Fis.df)
as_tibble(Fis.df)
```

<<<<<<< HEAD
=======

>>>>>>> 42d684c33e35ae838a61ecf2b5856bec74efb5e7
### Visualize heterozygosity
```{r}
pobs <- ggplot(gendivstats, aes(x = factor(Pop), y = Hobs.pop, color = Pop))
pobs <- pobs + geom_point(size = 3)
pobs <- pobs + scale_color_manual(values = pop_cols)
pobs <- pobs + labs(title = "Population level observed heterozygosity", 
         x = "Population", y = "Observed het")
pobs <- pobs + theme_classic()
pobs <- pobs + theme(axis.text.x = element_text(angle=45, hjust=1))
pexp <- ggplot(gendivstats, aes(x = factor(Pop), y = Hexp.pop, color = Pop))
pexp <- pexp + geom_point(size = 3)
pexp <- pexp + scale_color_manual(values = pop_cols) 
pexp <- pexp + labs(title = "Population level expected heterozygosity", 
         x = "Population", y = "Expected het")
pexp <- pexp + theme_classic()
pexp <- pexp + theme(axis.text.x = element_text(angle=45, hjust=1))
pfis <- ggplot(gendivstats, aes(x = factor(Pop), y = as.numeric(format(FIS, scientific = F)), color = Pop)) 
pfis <- pfis + geom_abline(slope = 0, color = "gray")  
pfis <- pfis + geom_point(size = 3) 
pfis <- pfis + scale_color_manual(values = pop_cols) 
pfis <- pfis + labs(title = "Population level inbreeding coefficient", 
         x = "Population", y = "FIS")
pfis <- pfis + theme_classic()
pfis <- pfis + theme(axis.text.x = element_text(angle=45, hjust=1))
pobs
pexp
pfis
```
<<<<<<< HEAD
## Genetic distance between locality and year combos. This is FST but can easily change
```{r, echo = FALSE}
pop.fst <- genet.dist(Alewife.genind, method = "WC84")
pop.fst.df <- as.data.frame(as.matrix(round(pop.fst, 3)))
pop.fst.df
# write.csv(pop.fst.df,"RH_M3_fst.csv")
```

## Genetic structure
Transfer vcf to the cluster and run fastStructure.sh, then copy output directory to working directory. Alternatively, run fastStructure commands from Terminal on own computer. Follow hackmd: https://hackmd.io/rr_rXY6aSGmRBSqnYV6iBA?view
The first portion can be skipped if using structure_threader and plot.ly to generate barplots.
```{r, fig.width = 6,fig.height = 6}
# sfiles <- list.files(path = "./RH_M3_fastStructure/RH_M3", pattern = "*meanQ",full.names = T)
# slist <- readQ(files=sfiles)
# 
# labels <- popmap.filtered
# labels$sort <- recode(labels$V2, EastGrand_2004="a", EastGrand_2018="b", 
#                            GrandFalls_2004="c", GrandFalls_2019="d", Woodland_2019="e",
#                            Milltown_2004="f", Milltown_2018="g",
#                            Dennis_2004="h")
#fastStructure barplots don't display easily in markdown so the following code writes to a file called "qplot.png". Colors are not meaningful from one K to the next.
# #this is kind of clunky
# pq <- plotQ(slist[c(1,3:9,2),1)],imgoutput="join",returnplot=F,exportplot=T,exportpath="./RH_M3_fastStructure/",outputfilename = "qplot",imgtype="png",basesize=11, grplab=labels[,2:3], selgrp = "sort", ordergrp = T, grplabsize=4, grplabangle = 20,grplabheight = 15,width = 30, linesize=0.8,pointsize=4,panelratio = c(1,1.5))
# 
# s2 <- readQ("./RH_M3_fastStructure/RH_M3/fS_run_K.2.meanQ", indlabfromfile = FALSE)
# rownames(s2[[1]]) <- labels$V1
# pindv <- plotQ(s2,imgoutput="sep",returnplot=F,exportplot=T,exportpath="./RH_M3_fastStructure/RH_M3/",outputfilename = "K2",imgtype="png",basesize=11, selgrp = "sort", grplab=labels, ordergrp = T, grplabsize=2, grplabangle = 90,grplabheight = 15,width = 30, linesize=0.8,pointsize=4,panelratio = c(1,1.5))
# Plot Marginal Likelihood vs. K
lfiles <- list.files(path = "./RH_M3_fastStructure/RH_M3", pattern = "*log",full.names = T)
lfiles
k.df <- data.frame(matrix(ncol = 2, nrow = 10))
names(k.df) <- c("K","Marginal_Likelihood")
# Filenames are out of order, 10 comes before 2, so need to fix that
k.df$K <- c(1,10,2,3,4,5,6,7,8,9)
for (i in 1:length(lfiles)){
  k.df$Marginal_Likelihood[i] <- 
    as.numeric(str_sub(grep("Marginal Likelihood = ", 
                            readLines(lfiles[[i]],),value = TRUE),-13))
=======

































###Extra code - not needed now but could be helpful later
```{r}
#Change plot window to make it easier to visualize trends as # of PCs increases.
par(mfrow = c(2,2))
#find clusters
# k <- find.clusters(Alewife.genlight, scale = FALSE)
#Loop over different numbers of PCs and plot k vs BIC
#Values originally 15-100, changed to 1-50
for(i in seq(1, 50, by = 5)){
  var <- paste0("k.",i,".PCs") #Make name to save output
  k <- find.clusters(genlight, scale = FALSE, n.pca = i, choose.n.clust = FALSE, criterion = "diffNgroup") #run main function
  plot(k$Kstat, type = "b", col = "blue", main = paste0("PCs = ", i), ylab = "BIC", xlab = "k value") #Plot results
  assign(var, k) #Save output
>>>>>>> 42d684c33e35ae838a61ecf2b5856bec74efb5e7
}
```

### Run DAPC analysis to find optimal number of PCs
If scale is set to TRUE, then uninformative alleles may be given more weight
Set number of PCs to highest number of PCs that returns a reasonable k vs BIC plot. Select a k value that you think reasonably represents the data
```{r}
#Change plot window back to default
par(mfrow = c(1,1))
PCs <- 50
clust <- 2
k <- find.clusters(Alewife.genlight, scale = FALSE, n.pca = PCs, n.clust = clust)
#Run DAPC using clusters and PCs specified above
#First time: copy and paste this line into the console--interactive:
#dapc1 <- dapc(genlight, k$grp, n.pca = PCs)
dapc1 <- dapc(genlight, k$grp, n.pca = PCs, n.da = 1)
#Optimize a score to find the number of PCs that minimizes false assignment
optim_a <- optim.a.score(dapc1)
k2 <- find.clusters(Alewife.genlight, scale = FALSE, n.pca = optim_a$best, n.clust = clust)
#First time: copy and paste this line into the console--interactive:
#dapc2 <- dapc(genlight, k2$grp, n.pca = optim_a$best)
dapc2 <- dapc(genlight, k2$grp, n.pca = optim_a$best, n.da = 1)
#a <- a.score(dapc1) #Look at a scores
#Plot results - change colors because Blair made fun of me
scatter.dapc(dapc2, pch = 19)
```

